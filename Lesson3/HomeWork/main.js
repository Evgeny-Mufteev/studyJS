// 1) "кот" > "код" Будет true  -  Сначала сравниваются первые символы двух строк, если первый символ первой строки
// больше/меньше чем первый символ второй строки - сравнение завершено. В данном случае первые два символа обеих
// строк равны, а юникод "т" больше чем "д".

// 2) "2" + 2 * "2" Будет "24"  -  Действуют правила как в математике сначала умножение потом сложение
// 2 * "2" будет 4, далее "2" + 4 При сложении строки, происходит строковое преобразование.

// 3) undefined == null Будет true  -  null и undefined, при не строгом равенстве равны друг другу и не равны
// любому другому значению.

// 4) undefined != null Будет false  -  по той же причине, что и третий пункт. undefined и null равны друг другу
// при не строгом равенстве, как в примере.

// 5) null == 0 Будет false  -  null при не строгом равенстве равен только undefined.

// 6) 2 > "3" Будет false  -  При сравении значений разных типов данных JS приводит каждое значение к числу получается
// 2 > 3 - false.

// 7) null - false + true Будет 1  -  В примере разные типы данных значит JS приводит каждое значение к числу получается
// 0 - 0 + 1 = 1

// 8) 1 / "l" Будет вычислительная ошибка NaN  -  так как число нельзя поделить на строку.

// 9) "2" * "3" Будет 6  -  Строковое преобразование происходит только при сложении в остальных случаях значения приводятся
// к числу.

// 10) 4 + 5 + "O" Будет "9О"  -  Сложение происходит слева направо, сначала 4 + 5 = 9, потом будет происходит строковое
//  преобразование цифра 4 складывается с заглавной буквой "О" будет "9О".

// 11) "l" + 4 + 5  Будет "l45"  -  Весь пример это строковое преобразование слева направо. Пример с подвохом
// где "l" похожа на цифру 1.

// 12) "4" - 2  Будет 2  -  Значения приводятся к числам, строковое преобразование происходит только при сложении
//  его здесь не будет.

// 13) "4" - "4x" Будет вычислительная ошибка NaN  -  из числа невозможно вычесть численнобуквенное значение.

// 14) “23” == 23 Будет true  -  так как оба значения равны, в данном примере необходимо сделать дополнительную проверку
// на число затем уже сравнивать типы.

// 15) null == false Будет false  -  null при не строгом равенстве равен только undefined и не какому другому значению
// даже falce

// 16) " -4 "/ 0 + 1 Будет -Infinity  -  Значения приводятся к числу 4 / 0 будет -Infinity + 1 ничего не изменится

// 17) null + 1 Будет 1  -  Значения приводятся к числу, null становится 0, 0 + 1 = 1

// 18) undefined + null Будет Not a Number  -  undefined при численном преобразовании NaN, null = 0,
// мы не можем сложить NaN + 0

// 19) 1 === “1” Будет false  -  Это строгое равенсво, JS будет сравнивать в первую очередь тип данных
// если тип данных не совпадет сразу falce

// 20) "2" > 10 Будет false  -  При сравнении разных типов данных js будет приводить их к одному типу в данном примере будет
// "2" > "10" что false

// 21) NaN == undefined Будет false  -  Undefined при не строгом равенстве равен только null
